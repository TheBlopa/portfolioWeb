{"ast":null,"code":"import { select } from 'd3-selection';\nimport { scaleLinear, scalePow } from 'd3-scale';\nimport { hierarchy, partition } from 'd3-hierarchy';\nimport { arc } from 'd3-shape';\nimport { path } from 'd3-path';\nimport { interpolate } from 'd3-interpolate';\nimport { transition } from 'd3-transition';\nimport Kapsule from 'kapsule';\nimport accessorFn from 'accessor-fn';\nimport Tooltip from 'float-tooltip';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".sunburst-viz .slice path {\\n  cursor: pointer;\\n}\\n\\n.sunburst-viz text {\\n  font-family: sans-serif;\\n  font-size: 12px;\\n  dominant-baseline: middle;\\n  text-anchor: middle;\\n  pointer-events: none;\\n  fill: #222;\\n}\\n\\n.sunburst-viz .text-contour {\\n  fill: none;\\n  stroke: white;\\n  stroke-width: 5;\\n  stroke-linejoin: 'round';\\n}\\n\\n.sunburst-viz .main-arc {\\n  stroke-width: 1px;\\n  transition: opacity .4s;\\n}\\n\\n.sunburst-viz .main-arc:hover {\\n  opacity: 0.85;\\n  transition: opacity .05s;\\n}\\n\\n.sunburst-viz .hidden-arc {\\n  fill: none;\\n}\\n\\n.sunburst-viz .tooltip {\\n  max-width: 320px;\\n  white-space: nowrap;\\n}\\n\\n.sunburst-viz .tooltip-title {\\n  font-weight: bold;\\n  text-align: center;\\n  margin-bottom: 5px;\\n}\\n\\n.sunburst-viz {\\n  position: relative;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar CHAR_PX_WIDTH = 7;\nvar CHAR_PX_HEIGHT = 14;\nvar sunburst = Kapsule({\n  props: {\n    width: {\n      \"default\": window.innerWidth\n    },\n    height: {\n      \"default\": window.innerHeight\n    },\n    data: {\n      onChange: function onChange(_, state) {\n        state.needsReparse = true;\n      }\n    },\n    children: {\n      \"default\": 'children',\n      onChange: function onChange(_, state) {\n        state.needsReparse = true;\n      }\n    },\n    sort: {\n      onChange: function onChange(_, state) {\n        state.needsReparse = true;\n      }\n    },\n    label: {\n      \"default\": function _default(d) {\n        return d.name;\n      }\n    },\n    labelOrientation: {\n      \"default\": 'auto'\n    },\n    // angular, radial, auto\n    size: {\n      \"default\": 'value',\n      onChange: function onChange(_, state) {\n        state.needsReparse = true;\n      }\n    },\n    color: {\n      \"default\": function _default(d) {\n        return 'lightgrey';\n      }\n    },\n    strokeColor: {\n      \"default\": function _default(d) {\n        return 'white';\n      }\n    },\n    nodeClassName: {},\n    // Additional css classes to add on each slice node\n    minSliceAngle: {\n      \"default\": .2\n    },\n    maxLevels: {},\n    excludeRoot: {\n      \"default\": false,\n      onChange: function onChange(_, state) {\n        state.needsReparse = true;\n      }\n    },\n    centerRadius: {\n      \"default\": 0.1\n    },\n    radiusScaleExponent: {\n      \"default\": 0.5\n    },\n    // radius decreases quadratically outwards to preserve area\n    showLabels: {\n      \"default\": true\n    },\n    tooltipContent: {\n      \"default\": function _default(d) {\n        return '';\n      },\n      triggerUpdate: false\n    },\n    tooltipTitle: {\n      \"default\": null,\n      triggerUpdate: false\n    },\n    showTooltip: {\n      \"default\": function _default(d) {\n        return true;\n      },\n      triggerUpdate: false\n    },\n    focusOnNode: {\n      onChange: function onChange(d, state) {\n        if (d && state.initialised) {\n          moveStackToFront(d.__dataNode);\n        }\n\n        function moveStackToFront(elD) {\n          state.svg.selectAll('.slice').filter(function (d) {\n            return d === elD;\n          }).each(function (d) {\n            this.parentNode.appendChild(this);\n\n            if (d.parent) {\n              moveStackToFront(d.parent);\n            }\n          });\n        }\n      }\n    },\n    onClick: {\n      triggerUpdate: false\n    },\n    onHover: {\n      triggerUpdate: false\n    },\n    transitionDuration: {\n      \"default\": 750,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    _parseData: function _parseData(state) {\n      if (state.data) {\n        var hierData = hierarchy(state.data, accessorFn(state.children)).sum(accessorFn(state.size));\n\n        if (state.sort) {\n          hierData.sort(state.sort);\n        }\n\n        partition().padding(0)(hierData);\n\n        if (state.excludeRoot) {\n          // re-scale y values if excluding root\n          var yScale = scaleLinear().domain([hierData.y1 - hierData.y0, 1]);\n          hierData.descendants().forEach(function (d) {\n            d.y0 = yScale(d.y0);\n            d.y1 = yScale(d.y1);\n          });\n        }\n\n        hierData.descendants().forEach(function (d, i) {\n          d.id = i; // Mark each node with a unique ID\n\n          d.data.__dataNode = d; // Dual-link data nodes\n        });\n        state.layoutData = hierData.descendants();\n      }\n    }\n  },\n  aliases: {\n    onNodeClick: 'onClick'\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n\n    state.chartId = Math.round(Math.random() * 1e12); // Unique ID for DOM elems\n\n    state.radiusScale = scalePow();\n    state.angleScale = scaleLinear().domain([0, 10]) // For initial build-in animation\n    .range([0, 2 * Math.PI]).clamp(true);\n    state.arc = arc().startAngle(function (d) {\n      return state.angleScale(d.x0);\n    }).endAngle(function (d) {\n      return state.angleScale(d.x1);\n    }).innerRadius(function (d) {\n      return Math.max(0, state.radiusScale(d.y0));\n    }).outerRadius(function (d) {\n      return Math.max(0, state.radiusScale(d.y1));\n    });\n    var el = select(domNode).append('div').attr('class', 'sunburst-viz');\n    state.svg = el.append('svg');\n    state.canvas = state.svg.append('g');\n    state.tooltip = Tooltip()(el); // Reset focus by clicking on canvas\n\n    state.svg.on('click', function () {\n      return (state.onClick || _this.focusOnNode)(null);\n    }) // By default reset zoom when clicking on canvas\n    .on('mouseover', function () {\n      return state.onHover && state.onHover(null);\n    });\n  },\n  update: function update(state) {\n    var _this2 = this;\n\n    if (state.needsReparse) {\n      this._parseData();\n\n      state.needsReparse = false;\n    }\n\n    var maxRadius = Math.min(state.width, state.height) / 2;\n    state.radiusScale.range([maxRadius * Math.max(0, Math.min(1, state.centerRadius)), maxRadius]);\n    state.radiusScaleExponent > 0 && state.radiusScale.exponent(state.radiusScaleExponent);\n    state.svg.style('width', state.width + 'px').style('height', state.height + 'px').attr('viewBox', \"\".concat(-state.width / 2, \" \").concat(-state.height / 2, \" \").concat(state.width, \" \").concat(state.height));\n    if (!state.layoutData) return;\n    var focusD = state.focusOnNode && state.focusOnNode.__dataNode.y0 >= 0 && state.focusOnNode.__dataNode || {\n      x0: 0,\n      x1: 1,\n      y0: 0,\n      y1: 1\n    };\n    var slice = state.canvas.selectAll('.slice').data(state.layoutData.filter(function (d) {\n      return (// Show only slices with a large enough angle and within the max levels\n        d.x1 > focusD.x0 && d.x0 < focusD.x1 && (d.x1 - d.x0) / (focusD.x1 - focusD.x0) > state.minSliceAngle / 360 && (!state.maxLevels || d.depth - (focusD.depth || (state.excludeRoot ? 1 : 0)) < state.maxLevels) && (d.y0 >= 0 || focusD.parent)\n      );\n    } // hide negative layers on top level\n    ), function (d) {\n      return d.id;\n    });\n    var nameOf = accessorFn(state.label);\n    var colorOf = accessorFn(state.color);\n    var strokeColorOf = accessorFn(state.strokeColor);\n    var nodeClassNameOf = accessorFn(state.nodeClassName);\n    var transition$1 = transition().duration(state.transitionDuration);\n    var levelYDelta = state.layoutData[0].y1 - state.layoutData[0].y0;\n    var maxY = Math.min(1, focusD.y0 + levelYDelta * Math.min(focusD.hasOwnProperty('height') ? focusD.height + 1 : Infinity, state.maxLevels || Infinity)); // Apply zoom\n\n    state.svg.transition(transition$1).tween('scale', function () {\n      var xd = interpolate(state.angleScale.domain(), [focusD.x0, focusD.x1]);\n      var yd = interpolate(state.radiusScale.domain(), [focusD.y0, maxY]);\n      return function (t) {\n        state.angleScale.domain(xd(t));\n        state.radiusScale.domain(yd(t));\n      };\n    }); // Exiting\n\n    var oldSlice = slice.exit().transition(transition$1).remove();\n    oldSlice.select('path.main-arc').attrTween('d', function (d) {\n      return function () {\n        return state.arc(d);\n      };\n    });\n    oldSlice.select('path.hidden-arc').attrTween('d', function (d) {\n      return function () {\n        return middleArcLine(d);\n      };\n    }); // Entering\n\n    var newSlice = slice.enter().append('g').style('opacity', 0).on('click', function (ev, d) {\n      ev.stopPropagation();\n\n      (state.onClick || _this2.focusOnNode)(d.data);\n    }).on('mouseover', function (ev, d) {\n      ev.stopPropagation();\n      state.onHover && state.onHover(d.data);\n      state.tooltip.content(!!state.showTooltip(d.data, d) && \"<div class=\\\"tooltip-title\\\">\".concat(state.tooltipTitle ? state.tooltipTitle(d.data, d) : getNodeStack(d).slice(state.excludeRoot ? 1 : 0).map(function (d) {\n        return nameOf(d.data);\n      }).join(' &rarr; '), \"</div>\").concat(state.tooltipContent(d.data, d)));\n    }).on('mouseout', function () {\n      return state.tooltip.content(false);\n    });\n    newSlice.append('path').attr('class', 'main-arc').style('stroke', function (d) {\n      return strokeColorOf(d.data, d.parent);\n    }).style('fill', function (d) {\n      return colorOf(d.data, d.parent);\n    });\n    newSlice.append('path').attr('class', 'hidden-arc').attr('id', function (d) {\n      return \"hidden-arc-\".concat(state.chartId, \"-\").concat(d.id);\n    }); // angular label\n\n    var angularLabel = newSlice.append('text').attr('class', 'angular-label'); // Add white contour\n\n    angularLabel.append('textPath').attr('class', 'text-contour').attr('startOffset', '50%').attr('xlink:href', function (d) {\n      return \"#hidden-arc-\".concat(state.chartId, \"-\").concat(d.id);\n    });\n    angularLabel.append('textPath').attr('class', 'text-stroke').attr('startOffset', '50%').attr('xlink:href', function (d) {\n      return \"#hidden-arc-\".concat(state.chartId, \"-\").concat(d.id);\n    }); // radial label\n\n    var radialLabel = newSlice.append('g').attr('class', 'radial-label');\n    radialLabel.append('text').attr('class', 'text-contour'); // white contour\n\n    radialLabel.append('text').attr('class', 'text-stroke'); // Entering + Updating\n\n    var allSlices = slice.merge(newSlice);\n    allSlices.style('opacity', 1).attr('class', function (d) {\n      return ['slice'].concat(_toConsumableArray(\"\".concat(nodeClassNameOf(d.data) || '').split(' ').map(function (str) {\n        return str.trim();\n      }))).filter(function (s) {\n        return s;\n      }).join(' ');\n    });\n    allSlices.select('path.main-arc').transition(transition$1).attrTween('d', function (d) {\n      return function () {\n        return state.arc(d);\n      };\n    }).style('stroke', function (d) {\n      return strokeColorOf(d.data, d.parent);\n    }).style('fill', function (d) {\n      return colorOf(d.data, d.parent);\n    });\n    var computeAngularLabels = state.showLabels && ['angular', 'auto'].includes(state.labelOrientation.toLowerCase());\n    var computeRadialLabels = state.showLabels && ['radial', 'auto'].includes(state.labelOrientation.toLowerCase());\n\n    if (computeAngularLabels) {\n      allSlices.select('path.hidden-arc').transition(transition$1).attrTween('d', function (d) {\n        return function () {\n          return middleArcLine(d);\n        };\n      });\n    } // Ensure propagation of data to labels children\n\n\n    allSlices.select('text.angular-label').select('textPath.text-contour');\n    allSlices.select('text.angular-label').select('textPath.text-stroke');\n    allSlices.select('g.radial-label').select('text.text-contour');\n    allSlices.select('g.radial-label').select('text.text-stroke'); // Show/hide labels\n\n    allSlices.select('.angular-label').transition(transition$1).styleTween('display', function (d) {\n      return function () {\n        return computeAngularLabels && (state.labelOrientation === 'auto' ? autoPickLabelOrientation(d) === 'angular' : angularTextFits(d)) ? null : 'none';\n      };\n    });\n    allSlices.select('.radial-label').transition(transition$1).styleTween('display', function (d) {\n      return function () {\n        return computeRadialLabels && (state.labelOrientation === 'auto' ? autoPickLabelOrientation(d) === 'radial' : radialTextFits(d)) ? null : 'none';\n      };\n    }); // Set labels\n\n    computeAngularLabels && allSlices.selectAll('text.angular-label').selectAll('textPath').text(function (d) {\n      return nameOf(d.data);\n    });\n    computeRadialLabels && allSlices.selectAll('g.radial-label').selectAll('text').text(function (d) {\n      return nameOf(d.data);\n    }).transition(transition$1).attrTween('transform', function (d) {\n      return function () {\n        return radialTextTransform(d);\n      };\n    }); //\n\n    function middleArcLine(d) {\n      var halfPi = Math.PI / 2;\n      var angles = [state.angleScale(d.x0) - halfPi, state.angleScale(d.x1) - halfPi];\n      var r = Math.max(0, (state.radiusScale(d.y0) + state.radiusScale(d.y1)) / 2);\n      if (!r || !(angles[1] - angles[0])) return '';\n      var middleAngle = (angles[1] + angles[0]) / 2;\n      var invertDirection = middleAngle > 0 && middleAngle < Math.PI; // On lower quadrants write text ccw\n\n      if (invertDirection) {\n        angles.reverse();\n      }\n\n      var path$1 = path();\n      path$1.arc(0, 0, r, angles[0], angles[1], invertDirection);\n      return path$1.toString();\n    }\n\n    function radialTextTransform(d) {\n      var middleAngle = (state.angleScale(d.x0) + state.angleScale(d.x1) - Math.PI) / 2;\n      var r = Math.max(0, (state.radiusScale(d.y0) + state.radiusScale(d.y1)) / 2);\n      var x = r * Math.cos(middleAngle);\n      var y = r * Math.sin(middleAngle);\n      var rot = middleAngle * 180 / Math.PI;\n      middleAngle > Math.PI / 2 && middleAngle < Math.PI * 3 / 2 && (rot += 180); // prevent upside down text\n\n      return \"translate(\".concat(x, \", \").concat(y, \") rotate(\").concat(rot, \")\");\n    }\n\n    function angularTextFits(d) {\n      var deltaAngle = state.angleScale(d.x1) - state.angleScale(d.x0);\n      var r = Math.max(0, (state.radiusScale(d.y0) + state.radiusScale(d.y1)) / 2);\n      var perimeter = r * deltaAngle;\n      return nameOf(d.data).toString().length * CHAR_PX_WIDTH < perimeter;\n    }\n\n    function radialTextFits(d) {\n      var availableHeight = state.radiusScale(d.y0) * (state.angleScale(d.x1) - state.angleScale(d.x0));\n      if (availableHeight < CHAR_PX_HEIGHT) return false; // not enough angular space\n\n      var availableLength = state.radiusScale(d.y1) - state.radiusScale(d.y0);\n      return nameOf(d.data).toString().length * CHAR_PX_WIDTH < availableLength;\n    }\n\n    function autoPickLabelOrientation(d) {\n      // prefer mode that keeps text most horizontal\n      var angle = (state.angleScale(d.x0) + state.angleScale(d.x1)) / 2 % Math.PI;\n      var preferRadial = angle > Math.PI / 4 && angle < Math.PI * 3 / 4;\n      return preferRadial ? radialTextFits(d) ? 'radial' : angularTextFits(d) ? 'angular' : null : angularTextFits(d) ? 'angular' : radialTextFits(d) ? 'radial' : null;\n    }\n\n    function getNodeStack(d) {\n      var stack = [];\n      var curNode = d;\n\n      while (curNode) {\n        stack.unshift(curNode);\n        curNode = curNode.parent;\n      }\n\n      return stack;\n    }\n  }\n});\nexport { sunburst as default };","map":null,"metadata":{},"sourceType":"module"}